# Day17 요약 및 헷갈리는 개념

## 멀티 catch 블럭

## 예외 발생시키기

* 컴파일러 예외처리 확인 O Exception 클래스들 : checked 예외
* 컴파일러 예외처리 확인 X RuntimeException 클래스들 : unchecked 예외

* unchecked 예외를 필수로하면 배열 모두 try-catch 해야하기에 나누어서 예외를 체크함.

## 메서드 예외 선언

* 메서드에 예외를 선언하는 것은 예외를 처리하는 것이 아니라 자신을 호출한 메서드에게 예외를 전달하여 떠맡김

## try-catch-finally

* return 문을 만나도 finally 블럭 문장은 수행됨.

## 예외 되던지기

* 양쪽에서 예외를 처리함.
* 반환값이 있는 return 문의 경우, catch블럭에도 return 문이 있어야함.
    * return문 대신 예외를 호출할 메서드로 예외를 전달해도 가능.

## 연결된 예외

1. 예외를 단순화하기 위함
2. 필수예외(chekced) -> 선택(unchecked) 변경하기위함

* 여러가지 예외를 큰 분류로 묶으면 되나 상속관계를 변경해야하기에 포함으로써 활용.
    * 그러므로 **예외를 포함시켜서 한 번에 처리함 -> 연결된 예외**
* Exception 예외를 RuntimeException (필수(checked) -> 필수x(unchecked)) 으로 감싸어서 활용.

## Objects 클래스

* Object 클래스 멤버변수가 없는 이유??
    1. this 를 활용할 수 있기 때문.
    2. 자손에서 사용할 수 있기 때문.
* 객체와 타입을 비교할 때 자주 쓰임.

```java
// 1 : 값
// Integer.valueOf(1) : 값
// String : 값 객체
``` 
## 얕은 복사 vs 깊은 복사

* 얕은 복사 - 데이터를 읽을 때
* 깊은 복사 - 데이터를 쓸 때 (원본에 영향을 미치지 않으므로)                                                                                                                                                         

## String 클래스

**불변 - 변경 불가능한 클래스**

* String 클래스와 직접적인 연관을 가졌으며, 변하지 않는 클래스입니다.
* 바꿀 때 새로운 것이 생기는 것.

```java
String a = "a";
String b = "b";
String a = a + b;
```

* 3번째 줄에서 a를 바꾸는 것이 아니라 새로운 문자열이 담긴 "ab" 를 생성하는 인스턴스가 생성되는 것임.

## 빈 문자열

```java
char[] chArr = new char[0];
int[] iArr = {};
```

* 길이가 0인 배열을 나타냄.
* null 말고 "" 공백으로 초기화하자

> 이해안되면 실습 많이 해라...


