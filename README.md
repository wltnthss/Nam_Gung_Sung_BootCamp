# Nam_Gung_Sung_BootCamp
남궁성강사님 9기 부트캠프 (23.10.16 ~ 24.03.15)

1. 프로그래밍 기초(4주) - 알고리즘 기본(400문제), Java, 객체지향개념과 설계, TDD, HTML & CSS
2. 웹프로그래밍(4주) - Spring + MyBatis, SQL기본(MySQL), JavaScript기본, Web기본
3. 개인 프로젝트(4주) - Spring으로 쇼핑몰 만들기, JavaScript심화, DB모델링, git, Spring Boot + JPA
4. 팀 프로젝트(8주) - 1차 개발, 교차 테스트, 1차 개발 리뷰, 2차 개발, 최종 테스트, 2차 개발 리뷰. 프로젝트 발표


## 자바의 정석 나만의 요약집 정리 1~14장 (하루에 1번씩 출퇴근길에 보기)

<details>
<summary style="font-size:20px">자바의 정석</summary>
<div markdown="1">

**객체지향 4대 핵심개념 적고, 한줄로 설명**

1. 캡슐화 : 외부로부터 데이터를 보호하기 위해서
2. 상속 : 두 클래스를 자식,부모관계를 맺어주고 기존 클래스로부터 새로운 클래스를 작성하는 것
3. 추상화 : 클래스의 공통된 기능을 모아서 부모 클래스로 만드는 것
4. 다형성 : 부모 타입의 참조변수로 자식 클래스의 인스턴스를 생성하는 것

**객체지향 특징 세 가지**

1. 코드의 재사용성
2. 유지보수 용이
3. 코드 중복 제거

**클래스**

* 정의 및 용도 : 객체를 정의하고 생성해서 사용하기 위함.

1. 객체를 정의해놓은 설계도
2. 사용자 정의 타입
3. 변수 + 메서드의 묶음

* 클래스를 인스턴스화 -> 인스턴스(객체)

**객체**

* 실제로 존재하는 것 (인스턴스 변수의 묶음)
* 객체 == 인스턴스

**변수의 종류**

1. 클래스영역 
   1. cv : 클래스변수 - 클래스가 메모리에 올라갈 때 생성, 객체를 생성할 필요 X, 공통적인 속성으로 사용
   2. iv : 인스턴스변수 - 객체를 생성할 때 생성, 객체를 생성해야 사용 가능, 개별 속성으로 사용
2. 메서드영역
   1. lv : 지역변수 - 클래스이외의 영역 (메서드, 생성자, 초기화블럭), 메서드 종료시 자동제거됨.

* cv는 하나의 저장공간을 공유하므로 항상 공통된 값을 갖고 iv는 각기 다른 값을 가짐.

**클래스메서드와 인스턴스메서드**

* static 메서드는 인스턴스 메서드 사용 불가 why? 
  * static 메서드는 클래스가 메모리에 올라갈 때 생성되는 반면 객체는 생성시에 만들어지므로 없을 경우가 있을 수도 있어서.
* 인스턴스 메서드에서는 static 메서드를 호출 가능함.
   
**오버로딩 조건3가지**

1. 메서드의 이름이 같아야함.
2. 매개변수의 타입이나 개수가 달라야함.
3. 반환타입은 영향이 없음.

**오버라이딩 조건3가지**

1. 부모타입의 예외개수보다 적어야함.
2. 부모타입의 접근 제어자보다 좁으면 안됨. 
3. 선언부가 일치함.

**생성자 조건5가지**

* 인스턴스 초기화 메서드

1. 클래스와 이름이 같아야함.
2. 리턴값이 없음.
3. 생성자는 반드시 한 개 존재해야함.
4. 생성자가 없으면 컴파일러가 기본 생성자를 하나 생성해줌.
5. 생성자의 첫째 줄에는 this() 나 super()가 들어가야함.

**생성자 this()**

1. 생성자에서 다른 생성자를 호출할 때 this()를 사용함.
2. 다른 생성자 호출 시 첫 줄에서만 사용 가능함.(다른 생성자로 인해 호출이전의 초기화 작업이 무의미하므로)

**참조변수 this**

* 인스턴스 변수와 지역변수의 이름이 같을 때 구분하기위함.
* this가 붙으면 iv이고 안붙으면 매개변수와 가까운 lv임.
* 인스턴스 자신을 가르키는 참조변수.
* static 메서드에서는 사용 불가함.

**클래스 변수, 인스턴스 변수 초기화 순서 과정**

* 멤버변수 - 자동초기화, 지역변수 - 직접 초기화해줘야함.
* 클래스변수는 클래스가 메모리에 올라갈 때 초기화되고, 인스턴스 변수는 인스턴스가 생성될 때 초기화됨.

* 클래스 변수
1. 기본값 -> 명시적 초기화 -> 클래스 초기화 블럭 static{} 
   
* 인스턴스 변수
1. 기본값 -> 명시적 초기화 -> 인스턴스 초기화 블럭 {} -> 생성자

* cv -> iv 순으로 초기화되며, 자동(기본값) -> 간단(명시적 초기화) -> 복잡순(초기화 블럭, 생성자) 으로 초기화됨.

**기본형 매개변수, 참조형 매개변수**

* 기본형 매개변수는 변수의 값을 읽기만 가능
* 참조형 매개변수는 변수의 값을 읽고 변경 가능

**상속**

1. 기존 클래스로 다른 클래스를 작성하는 것
2. 두 클래스간의 부모와 자식으로 관계를 맺어주는 것
3. 자식의 멤버개수는 부모보다 적을 수 없음.
4. 자식은 부모의 모든멤버를 상속받음(생성자, 초기화블럭 제외)

* 자바는 단일상속만 허용함 (비중이 높은 클래스만 상속하고, 나머지는 포함관계 활용)
* 자식클래스 extends 부모클래스
* 상속 관계 ~는 ~이다 ( is a 관계)
* 포함 관계 ~는 ~를 가지고 있다 ( has a 관계) **(대부분의 경우 포함관계임)**

**Objects클래스는 iv가 하나도 없는데, 인스턴스 메서드를 가지는 이유**

* Objets 클래스는 모든 클래스의 부모 클래스로 자식 클래스들이 오버라이딩해서 iv를 쓸 수 있기 때문임.

**참조변수 super**

* 객체 자신을 가르키는 참조변수
* 조상의 멤버를 자신의 멤버와 구분할 때 사용

**부모 생성자 super()**

1. 부모 생성자 호출 시 사용 (생성자와 초기화 블럭은 상속이 안되므로)
2. 부모 멤버는 부모의 생성자를 호출해서 초기화
3. 자식의 생성자는 자신이 선언한 변수만 초기화 할 수 있음.
4. 생성자의 첫 줄에 반드시 생성자를 호출해야함.

**접근제어자**

* public > protected > default > private 
* 전체 > 같은 패키지, 자식 클래스 > 같은 패키지 > 같은 클래스 순으로 접근 제어 권한을 가짐.

1. 외부로부터 데이터를 보호하기 위함
2. 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위함.

**final**

1. 클래스 - 상속이 불가능함.
2. 메서드 - 오버라이딩이 불가능함.
3. 변수 - 상수로써 활용함.

**다형성**

1. 부모타입 참조변수로 자식타입 객체를 다룰 수 있음.
2. 하나의 배열에 여러 종류의 객체를 저장할 수 있음.

* 참조변수가 사용할 수 있는 멤버의 개수는 인스턴스 멤버개수보다 같거나 적어야함.
* 참조변수타입과 인스턴스타입은 보통 일치하지만 일치하지 않을 수도 있음.

**추상클래스**

1. 미완성 설계도
2. 인스턴스로 생성불가
3. 인스턴스 변수, 생성자, 메서드를 일반 클래스와 같이 사용 가능
4. abstract 가 붙은 메서드는 자식 클래스에서 용도에 맞게 오버라이딩하여 사용함.
5. 클래스의 공통적인 기능을 찾아내서 부모클래스로 만듬으로써 사용함.

**인터페이스**

1. 추상메서드의 집합
2. 밑그림 역할
3. 인스턴스화 할 수 없으며 상수와, 추상메서드만을 가질 수 있음.
4. 추상클래스보다 추상화 정도가 높음.

* 인터페이스의 조상은 인터페이스만 가능(Object가 최고조상이 아님)
* 다중 상속 가능이 가능함.
* public, static, final, abstract 전부 생략 가능함.
* 상속과 구현 동시에 가능함.
* 인터페이스 타입의 변수로 인터페이스를 구현한 클래스의 인스턴스 참조 가능함.
* 일부만 구현할 경우 클래스앞에 abstract를 붙여서 추상 클래스로 만들어줘야함.

**인터페이스 장점**

1. 두 객체간의 중간 역할을 함으로써 객체간에 느슨한 결합을 가능하게 도와줌.
2. 서로 관계없는 클래스들을 형제 관계로 맺어줌으로써 활용 가능함.
3. 설계를 진행할 때 밑그림의 역할로 인터페이스를 활용하면 재사용성에 용이함.

**추상클래스 vs 인터페이스**

* 추상적인 용도는 동일하게 쓰이나 인터페이스는 iv, 생성자를 가질 수 없음

**예외**

* 예외처리 정의 - 예외 발생에 대비한 코드 작성
* 예외처리 목적 - 프로그램의 비정상적인 종료 방지

**에러 3가지**

1. 컴파일에러 : 컴파일 시에 발생하는 에러
2. 런타임에러 : 프로그램 실행 시에 발생하는 에러
3. 논리적에러 : 프로그래머의 작성 의도와 다르게 동작하는 것

**예외 클래스**

1. Exception 클래스들 : 사용자의 실수와 같은 외적인 요인에 의해서 발생하는 예외
2. RuntimeException 클래스들 : 프로그래머의 실수로 발생하는 예외

**예외 처리 방법5가지**

1. try-catch-finally - 예외 발생한 메서드 안에서 처리
2. 메서드 예외 선언
3. 예외 강제로 발생 시키기
4. 사용자 예외 선언
5. 예외 되던지기

**연결된 예외 장점2가지**

1. check예외를 unchecked예외로 바꿀 수 있음.
2. 큰 분류의 예외로 묶어서 사용할 수 있음.

**checked예외를 unchecked예외로 바꿔서 사용하는 이유**

* 예외처리를 선택적으로함으로써 무분별한 try-catch 문을 사용하지 않기 위함

**얕은 복사와 깊은 복사**

1. 얕은 복사 : 원본과 복사본이 같은 객체를 참고하며 단순 Cloneable 인터페이스를 구현한 clone 을 통한 복제를 사용함.
2. 깊은 복사 : 원본과 복사본이 다른 객체를 참고하고 원본의 객체를 복사하여 참조함.

**불변이란?**

* 객체 생성 후에 상태를 변경할 수 없는 것
* 재할당은 가능하지만 한번 할당하면 내부 데이터는 변경할 수 없음.
* 대표적인 불변 객체로는 String이 있음.
* 필드에서 사용할 때는 final을 붙여서 사용함.

1. 멀티쓰레드 환경에서 동기화를 고려하지 않아도됨.
2. GC 성능 향상.

**래퍼클래스**

* 기본형 값들을 객체로 변환하여 작업을 수행할 때 사용함.
* 오토박싱 : 기본형 값을 래퍼 클래스의 객체로 자동 변환

**컬렉션 프레임웍**

* 컬렉션 : 다수의 객체를 모아놓은 것
* 프레임웍 : 표준화된 프로그래밍 방식
* 컬렉션 프레임웍 : 다수의 객체를 모아놓은 표준화된 프로그래밍 방식

**컬렉션 프레임웍 핵심 인터페이스**

1. List
   * 순서 O, 중복 O
   * LinkedList, ArrayList, Stack, Vector
   * Collection 인터페이스를 상속받고 있음
2. Set
   * 순서 X, 중복 X
   * HashSet, TreeSet
   * Collection 인터페이스를 상속받고 있음
3. Map
   * 순서 X, Key 는 중복 X, Value 는 중복 O

**ArrayList**

* Vector는 동기화되어있지만 ArrayList는 동기화되어있지 않음.
* List 인터페이스를 구현하여 순서가 유지되고 중복을 허용함.

**ArrayList 삭제과정**

1. ArrayList는 index 번째 요소를 삭제함. ex) data[0] ~ data[5]
2. 중간 데이터 data[2] 2번째 요소를 삭제한다는 가정하에 list.remove(2); 호출함.
3. 삭제할 데이터 아래의 데이터를 한칸씩 위로 복사하여 삭제할 데이터 덮어씌우기
4. System.arraycopy(data, index+1, data, index, size-index-1)
5. 데이터가 한칸씩 옮겨졌으므로 마지막 데이터는 null로 변경 data[size-1] = null;
6. 데이터가 삭제되었으므로 size하나 감소 size--;
7. 마지막 데이터를 삭제하는 경우는 복사과정을 건너띄고 5번부터 수행함.

**LinkedList**

* 다음요소와 이전요소의 주소, 데이터를 저장할 수 있음.
* ArrayList에 비해서 접근 속도는 느리나, 비순차적인 데이터의 추가/삭제는 빠름.
* ArrayList가 접근 속도는 더 빠르고, 순차적인 데이터의 추가/삭제는 더 빠름.

**스택 & 큐**

* 스택 (Stack) - LastInFirstOut (LIFO) 구조 ex) 수식괄호검사, 브라우저 뒤/앞
  * 저장 - push(), 추출 - pop()
  * ArrayList 로 구현하는 것이 유리함
* 큐 (Queue) - FirstInFirstOut (FIFO) 구조 ex) 최근사용문서, 버퍼
  * 저장 - offer(), 추출 - poll()
  * LinkedList 로 구현하는 것이 유리함 (데이터를 꺼낼 때마다 데이터 복사가 발생)

**Comparator와 Comparable**

* Comparable - 기본 정렬기준을 구현하는데 사용하며 기본적으로 제공하는 인터페이스임.
* Comparator - 기본 정렬기준 외에 다른 기준으로 정렬하고자 할 때 사용.

**이진 검색 트리(binary search tree)**

1. 모든 노드는 최대 두 개의 자식노드를 가질 수 있음
2. 왼쪽 자식 노드 값이 부모 노드의 값보다 작고 오른쪽은 부모보다 커야함.
3. 검색과 정렬에 유리함.
4. 노드의 추가 삭제에 시간이 오래 걸림(배열보다 느림)
5. TreeSet, TreeMap 사용

**해싱**

* 해시함수를 이용해서 해시테이블에 데이터를 저장하고 검색하는 기법
* ArrayList와 LinkedList 의 조합
  
</div>
</details>


